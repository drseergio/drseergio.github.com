<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: tech | Sergey Pisarenko]]></title>
  <link href="http://drseergio.github.io/blog/categories/tech/atom.xml" rel="self"/>
  <link href="http://drseergio.github.io/"/>
  <updated>2016-08-02T20:01:55+02:00</updated>
  <id>http://drseergio.github.io/</id>
  <author>
    <name><![CDATA[Sergey Pisarenko]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Getting Better at Solving Coding (Interview) Problems]]></title>
    <link href="http://drseergio.github.io/blog/2016/07/08/getting-better-at-solving-coding-interview-problems/"/>
    <updated>2016-07-08T18:37:00+02:00</updated>
    <id>http://drseergio.github.io/blog/2016/07/08/getting-better-at-solving-coding-interview-problems</id>
    <content type="html"><![CDATA[<p>This is part 2 of a series of articles themed &ldquo;Preparing for Software Engineer Interviews&rdquo;. My goal with the series is to document the steps I took while preparing for interviews for a software engineering position after working six years in predominantly support-leaning roles. I won&rsquo;t break new ground here but rather share personal experience &mdash; anything you see here is an echo of what you can find elsewhere on the Internet. But too much of a good thing could be bad. Too much advice obscures itself and makes it hard to navigate. In <a href="/blog/2016/06/12/the-kata-of-code/">part 1</a> I explained how I improved my knowledge of algorithms and data-structures as well as introduced a regular coding exercise. In this part I will explain how I went about improving interview coding skills.</p>

<p>When I was originally confronted with preparing for interviews I pulled many online resources together: posts on quora and stackoverflow, blog posts, articles and forum discussions. Some of the posts were quite detailed and comprehensive. There is lot of common advice but I struggled because there was just too much to do and too many ways to go about it. I decided to follow a simple plan which I will shortly explain below.</p>

<p>What is so special about software engineer interviews? The basic premise of most coding interviews (we&rsquo;re talking about interviews at mostly large tech companies here) is to present a candidate with a novel problem that he has never seen before to see how good his reasoning and problem solving skills are. Presumably, a coding interview is a good indicator of candidate&rsquo;s abilities and real-world productivity. Seeing how the candidate struggles under pressure, comes up with brilliant solutions and communicates with the interviewer is a telltale sign of his future success at the company. Unfortunately, that&rsquo;s only a presumption and the reality is complicated but at the moment most tech companies stick to the same format which means that candidates must eventually go through it. So let&rsquo;s look through some preparation ideas and shed some bullshit along the way.</p>

<p>First, there&rsquo;s the novelty issue. It is not feasible to come with a completely new coding problem for every interview. Instead, inteviewers usually rely on a limited repertoire of problems. These problems eventually leak out and get shared online. More importantly, though, many problems share similar problem-solving strategies. Once the insight is known to a candidate the problem reduces to relatively painless translation to code. I&rsquo;ve seen judgements against candidates that try to memorize solutions. But how can a solution be memorized? There are not 10 or 20 problems out there. There are hundreds, even thousands. Nobody would try to memorize the solution code line by line. But it is fair to assume that candidates memorize ideas and patterns behind the problems. How else could the candidates do well on interviews? Let&rsquo;s take mathematics. Undeniably there is lots of memorization involved when learning any subject in mathematics. We can&rsquo;t assume that candidates come up with algebra concepts from scratch during their short stay. Why then would it be fair to expect candidates to come up with algorithms that took very distinguished and persistent computer scientists and engineers to come up with?</p>

<p>In short, obtaining the insight and patterns behind coding problems and memorizing the right things is in my opinion the essence of interview preparation. Even the most distinguished engineers admit that in their day to day work they rarely get a chance to tackle difficult algorithmic challenges. I&rsquo;m not saying that advanced skills are unnecessary and everyone should be an API coding monkey. I&rsquo;m saying that candidates must work through typical coding problems, extract vital problem solving patterns and approaches. The fact remains, though, that some amount of memorizing is unavoidable. If a candidate didn&rsquo;t have a need to optimize things at a very low level it&rsquo;s unlikely he&rsquo;ll come up with a good solution for bit twiddling questions even though he understands the underlying concepts well. He just wouldn&rsquo;t have enough time. And certain efficient solutions are very clever to the point of being obscure and unintuitive. There&rsquo;s little chance of coming up with one during 45 stressful minutes.</p>

<p>In fact, I would go as far as to say that some solutions must be memorized almost to the point of line by line. Okay, maybe not that far. But there are a some smaller-sized questions that interviewers like to ask as a warm-up. For example, to implement a power function or the greatest common divisor function. The thing is, interviewers expect flawless and, most importantly, quick (read immediate) implementation. Even if a candidate understands the idea it might take too long to translate that idea into code on the board. Plus, there are many possibilities for subtle common bugs, such as off-by-one errors, out-of-bounds, etc. Normally, a programmer is not rushed so there&rsquo;s sufficient time to think, sketch pseudocode, implement and take care of edge cases. Because the problem is not difficult the interviewer will pick apart even the smallest mistakes and attach disproportionate weight to them. Clearly, candidates that prepared well will look more capable although it is debatable if their performance difference would translate in anything measurable in the real world.</p>

<p>Once a candidate gets exposed to a sufficient amount of problems (in the range of hundreds) there comes a plateau point. That&rsquo;s completely normal and expected. Despite the acquired experience many problems won&rsquo;t seem any easier. That&rsquo;s also normal. In fact, this discourages many aspiring competitive programmers from further pursuing the challenge. Certain kinds of problems do not fall under neat patterns and require a different mindset. I personally haven&rsquo;t yet managed to overcome this plateau. The good news is that such problems are rarely, if ever, asked in interviews. The bad news is that getting good at difficult problems worsens performance at interview problems. And the reason is that one tries to apply unconvential and complex data-structures and algorithms whereas most interview coding problems are centered around a set of relatively simple tools. Dead-ends are time consuming and reduce chances of solving the problem. After going through many rounds of mock interviews (which I discuss in the 3rd part of the series) I realized that I must recalibrate my toolkit and stick to simplest tools unless everything else fails. When my first thought reaches for a suffix tree I resist and instead try one of the following (not exhaustive): sorting, using a queue/stack, traversing, reversing, doing binary search, recursing. I also find it helpful to think of a brute force solution first. The lesson is that most coding problems are simple and rarely involve anything exotic. When they do the interviewer is prepared to almost immediately spill the beans on the magic insight.</p>

<p>So how to go about actually preparing? I have taken a whole month of full-time effort to specifically practice interview coding problems. There are many popular sources with coding problems, to name a few:</p>

<ul>
<li><p><a href="https://www.topcoder.com/">TopCoder</a> &mdash; not suited well for interview preparation because of the nature of the problems, weird problem classification and an arcane UI. TopCoder is really a tool for competitive programming and it&rsquo;s not designed for practicing interview problems. Given time constraints and different goals in mind I wouldn&rsquo;t spend time on TopCoder.</p></li>
<li><p><a href="https://uva.onlinejudge.org/">UVA judge</a> &mdash; automated system for submitting solutions to various competitive programming problems. Suffers from similar problems as TopCoder. Also, just like with TopCoder, it is hard to keep track of progress or to cover all topics.</p></li>
<li><p><a href="https://www.amazon.com/Cracking-Coding-Interview-Programming-Questions/dp/0984782850">Cracking the Coding Interview book</a> &mdash; extremely popular book with around 150 coding problems and solutions. I went through an earlier edition years ago. Haven&rsquo;t seen or used the recent one.</p></li>
<li><p><a href="https://www.interviewbit.com/">interviewbit</a> &mdash; a well designed system specifically for preparing for interviews. Problems are classified by topics. There&rsquo;s search functionality that lets, for example, to search for problems asked at certain companies. interviewbit also has an excellent gamified progress tracking functionality. Unfortunately, I found out too late about it. Otherwise, I would have likely used it as a primary preparation tool.</p></li>
<li><p><a href="https://www.amazon.com/Elements-Programming-Interviews-Java-Adnan/dp/1517671272">Elements of Programming Interviews in Java (EPI) book</a> &mdash; this is my choice! The books comes with hundreds of problems with clear explanations of brute-force and optimal solutions. C++ edition is also available.</p></li>
<li><p><a href="https://www.hackerrank.com/">HackerRank</a> &mdash; feels like a system which serves both competitive programming and interview preparation well. There are many practice problems classified by topics and regular hosted competitions. I have used HackerRank as a complementary resource.</p></li>
<li><p><a href="http://www.geeksforgeeks.org/">GeeksForGeeks</a> &mdash; a daily blog of coding problems. I have yet to come across an interview coding problem that is not published there.</p></li>
</ul>


<p>Once I settled on a primary source I&rsquo;ve done two passes:</p>

<ol>
<li><p>Go through every problem in the EPI book and solve them algorithmically without writing any code. I&rsquo;ve set a time limit of 10-15 minutes per problem. Once the time limit expired I consulted the solution. I think it&rsquo;s better to have a time limit rather than get stuck for hours on a problem. Generally, I think it&rsquo;s great to sometimes persist on a problem until it cracks but given the goals of interview preparation it&rsquo;s more effective to absorb as many concepts as possible. For every problem I wrote down the main insight. It took me about 2 weeks to finish the whole book.</p></li>
<li><p>Go through every solved problem and write code for it. This is where I realized that my previously-written notes were terrible so I often had to solve the problems again. I wrote code on paper and I felt that writing code with the insight in hand is easy. I&rsquo;m sure there are folks for whom finding the insight is easier.</p></li>
</ol>


<p>I complemented EPI with problems from the HackerRank site. Finally, during two weeks leading to interviews I also solved every problem marked with the company I was applying for on interviewbit. You&rsquo;d be surprised just how often widely publicized problems are still actively asked in interviews so it pays to go through them. I haven&rsquo;t actually used interviewbit as a platform. Instead, I just read the problem descriptions and solved them on paper. Whenever I got stuck I consulted the hints or complete editorials (solutions).</p>

<p>After putting so much effort in the preparation can I say it was worth it? Did it help to get an offer? Getting good at solving coding interview problems takes a considerable effort and it is not a sure guarantee of success. However, a lack of such preparation is a sure guarantee of failure. There are too many factors vying for the final hire/no hire decision and success is anything but guaranteed. Just like with the algorithm and data-structure study I feel this effort made me a little bit better as a programmer. And just like with <a href="/blog/2016/06/12/the-kata-of-code/">algorithm katas</a> I would like to adopt a habit of regularly solving coding problems to improve further.</p>

<p>In the concluding part 3 I will talk about the final interview preparation steps and also talk about the psychological challenges that many candidates such as myself face before and during the interviews and the ways to tackle them.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Kata of Code]]></title>
    <link href="http://drseergio.github.io/blog/2016/06/12/the-kata-of-code/"/>
    <updated>2016-06-12T15:28:00+02:00</updated>
    <id>http://drseergio.github.io/blog/2016/06/12/the-kata-of-code</id>
    <content type="html"><![CDATA[<p>This is part 1 of a series of articles themed &ldquo;Preparing for Software Engineer Interviews&rdquo;. My goal with the series is to document the steps I took while preparing for interviews for a software engineering position after working six years in predominantly support-leaning roles. I won&rsquo;t break new ground here but rather share personal experience &mdash; anything you see here is an echo of what you can find elsewhere on the Internet. But too much of a good thing could be bad. Too much advice obscures itself and makes it hard to navigate. In this part I will explain how I went about refreshing and improving knowledge of algorithms and data structures.</p>

<p>A fancy word makes even the most mundane things sound legitimate. Enter &lsquo;kata&rsquo; &mdash; a fancy way of saying that one does something mundane, regularly. Originally, the Japanese word &lsquo;kata&rsquo; stands for a very specific kind of practice in traditional arts. But in the programming world it&rsquo;s synonymous with a repetitive coding practice. I have no opinion in the linguistic department but I believe the practice might have some substance. Let me rewind a little bit.</p>

<p>Exactly one year ago I <a href="/blog/2015/06/16/why-i-have-quit-an-awesome-job/">left a wonderful job in one of the best places to work</a> on this planet. With such a drastic move there&rsquo;s a multitude of reasons. One of the major ones is my ambition to become an excellent software engineer and steer away from the technical support role I had so far pursued.</p>

<p>The first obstacle on the way are the well-known and sometimes wacky software interviews that most respectable companies seem to rely on for choosing among candidates. To prepare myself for the challenge I devised a multi-month plan. About 3 months ago, as I was done with another full-time endeavour, I put the plan through its paces. In this article I&rsquo;ll do my best to explain the first step of the plan &mdash; the study and practice of algorithms and data-structures.</p>

<p>It&rsquo;s not like I&rsquo;ve never studied algorithms. In fact, I hold a computer science degree and have completed several excellent online algorithm-focused courses with top marks (<a href="https://www.coursera.org/course/algs4partI">Algorithms Part I</a>, <a href="https://www.coursera.org/course/algs4partII">Algorithms Part II</a>). But annoyingly if you had asked me to implement a path-finding algorithm or even an O(N*LogN) sorting algorithm I would have struggled without referring to technical books or articles. Should you have asked the same question straight after I had just completed the courses I would have absolutely no issues. From a limited personal survey of fellow engineers it is a very common situation. Few keep algorithms in their heads.</p>

<p>Clearly, without an excellent understanding of algorithms passing a coding interview is unlikely. Besides, algorithms and data structures are the cornerstones of computer science and software. Without the understanding of basic structures it&rsquo;s not possible to solve most of the coding challenges. So I dedicated the first month of preparation to the study of algorithms.</p>

<p>However, as I&rsquo;ve already learned, the chosen method of study is critical. It&rsquo;s all to easy to complete a course or a book and then forget everything few weeks after. It is also not sufficient to merely browse through a book or a bunch of articles. Superflous reading creates a perilous illusion of understanding. It is imperative to work through. That&rsquo;s why going through one algorithms book takes a month of full-time effort and not an afternoon. I also emphasize that I had completed algorithm courses before starting this effort. Otherwise, it would make sense to study through the online courses mentioned above first. It would also significantly lengthen the plan.</p>

<p>As there are many more algorithms than the time available to me I had to optimize. It makes little sense to study the most esoteric and domain-specific algorithms for the purpose of preparing for software interviews. I made a survey of interview-related Q&amp;As and websites and came up with the following initial list of algorithms and data structures (in no particular order):</p>

<pre><code>* Stack/Queue (based on LinkedList)
* Selection Sort
* SeparateChainingHashST
* LSD/MSD sort (Radix)
* Graph/Digraph/WeightedGraph
* Edge/EdgeWeightedGraph
* DFS/BFS
* Binary Search
* Weighted Quick Union
* Insertion Sort
* Shell Sort
* DFSPaths/BFSPaths
* Cycle detection in undirected graph
* Connected Components with DFS in undirected graph
* Bipartite check in undirected graph (two color)
* Merge Sort
* Bottom-up Merge Sort
* Quicksort
* 3-way Quicksort
* CountSort
* Min/MaxPQ
* Heapsort
* BST
* Red-black BST
* LinearProbingHashST
* Cycle detection in directed graph
* DFS order and Topological sort
* Kosaraju-Sharir Strong Connected Components in directed graph
* Kruskal MST
* Prim MST
* Dijkstra SP
* Acyclic SP
* Bellman-Ford SP
* Knuth-Morris-Prath search
* Boyer-Moore search
</code></pre>

<p>It is debatable if some of the algorithms in this list are already too complex for general software engineering interviews (knowledge of esoteric algorithms might be required for more senior or specialized roles). In fact, as practice went by I added a few additional ones and removed a few.</p>

<p>The book I chose for my study is &ldquo;<a href="https://www.amazon.com/Algorithms-4th-Robert-Sedgewick/dp/032157351X">Algorithms, 4th edition</a>&rdquo; from Robert Sedgewick at Princeton University. It&rsquo;s written by the same professor that teaches the corresponding online courses. What sets it apart from other famous algorithm texts is the focus on visually illustrating algorithms and doing algorithm-tracing exercises. Working through an algorithm on paper and tracing all the steps helps to grasp what the algorithm really does. Through these exercises I uncovered that my mental models for some of the algorithms were wrong. The other huge benefit of this book is a <a href="http://algs4.cs.princeton.edu/">complementary codesite</a> with lots of high-quality and clearly-written implementations of algorithms in Java.</p>

<p>My daily routine consisted of reading about one topic and related algorithms and then trying to re-implement the algorithms myself. As soon as I stumbled I looked-up the text. The complementary code is extremely readable. The implementations may lack some of the fanciest and trickiest optimizations but are invaluable tools for learning. Once I implemented the code I erased and started from scratch, testing thoroughness of my understanding.</p>

<p>As the days went by and I progressed further I felt that I no longer remembered the details of algorithms I had already worked-through. That&rsquo;s when I decided to introduce additional regular algorithm coding practice &mdash; katas. I grouped some of the algorithms together. Then during each practice session I would implement algorithms and data-structures from the top of my head, copying only test cases from the reference implementation. At times I would get stuck. In those moments I learned a little bit more about each algorithm. Often, I would get confused and need to look-up the reference implementation. Next time, though, the practice would become easier and more automatic. Katas keep the algorithm knowledge functional and fresh. Furthermore, being able to implement some of the tricky algorithms from the top of my head on a napkin increases confidence which may sometimes shake under the many stresses of interviews. Finally, being able to implement many algorithms quickly pays off in coding competitions.</p>

<p>I don&rsquo;t know if the original katas are canonical. My coding katas are certainly not. They evolve and change with time. At some point easier algorithms and data-structures become trivial and it no longer makes sense to practice them. I don&rsquo;t practice writing a stack/queue anymore. Sometimes I realize how similar few algorithms are so I leave one of them out. Many graph problems reduce to DFS. Occasionally I study through new algorithms and add them to katas. For example, I&rsquo;ve recently added SkipList and SuffixArray. I also group algorithms so that each kata is of similar size. At the moment I have <a href="https://github.com/drseergio/practice/tree/master/katas">5 katas in my repertoire</a>. It takes about 30-60 minutes to complete each one. I aim to complete all of the katas once a week &mdash; on average less than one kata per day. I&rsquo;m also timing my practice now to see how long each kata takes.</p>

<p><strong>Here&rsquo;s a distilled version of the algorithm study plan (~1 month of full-time effort)</strong>:</p>

<ol>
<li>List algorithms/data-structures you need to learn deeply. When in doubt leave it out. Make it as short as feasible. Can always add more later.</li>
<li>Choose an algorithms text. I recommend <a href="https://www.amazon.com/Algorithms-4th-Robert-Sedgewick/dp/032157351X">&ldquo;Algorithms, 4th edition&rdquo; by Robert Sedgewick</a>.</li>
<li>Schedule sufficient time each day to read the text and implement algorithms by hand. Keep premature enthusiasm at hand and keep the workload manageable. There&rsquo;s a reason it takes a month.</li>
<li>Collect algorithm implementations and group them into katas.</li>
<li>Regularly perform katas by reimplementing algorithms.</li>
<li>Revise katas, remove trivial algorithms and add new ones as you see fit.</li>
<li>Repeat 6, 7.</li>
</ol>


<p>I&rsquo;d like to believe that this study of algorithms and practice of katas will pay off. It is hard to say, taking into account the many factors that affect a hiring decision. Doing a comprehensive study like this won&rsquo;t guarantee success but doing nothing almost certainly guarantees failure. The study of algorithms is just the first interview preparation step. I&rsquo;ve introduced katas as means to not forget what I&rsquo;ve just learned. But as I&rsquo;ve practiced and grown my personal collection I see myself continuing with katas.</p>

<p>In the <a href="/blog/2016/07/08/getting-better-at-solving-coding-interview-problems/">next part (2)</a> I explain my strategy for getting better at solving coding problems.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to order Dell XPS 13 with US keyboard in Europe]]></title>
    <link href="http://drseergio.github.io/blog/2015/04/05/how-to-order-dell-xps-13-with-us-keyboard-in-europe/"/>
    <updated>2015-04-05T19:46:00+02:00</updated>
    <id>http://drseergio.github.io/blog/2015/04/05/how-to-order-dell-xps-13-with-us-keyboard-in-europe</id>
    <content type="html"><![CDATA[<p>I decided to purchase a laptop as I find myself longing for a computer away from my beloved workstation more often. Last time I bought a laptop was 8 years ago.</p>

<p>Dell built a laptop I feel genuinely excited about &ndash; the new XPS 13. It&rsquo;s as small as 11" machine with really narrow bezel. It comes with specs that are just right for me.</p>

<p><a href="/images/dellxps/dell_order_01.png"><img src="/images/dellxps/dell_order_01.png" width="500"></a></p>

<p>However, I&rsquo;ve learned that buying from Dell is not that easy! I was trying to order XPS 13 laptop with a US layout keyboard using Swiss regional site dell.ch. When I choose US keyboard I get presented with the following error:</p>

<p>&ldquo;The selection &ndash; MUI Etikett für Handauflage is incompatible with Tastatur&rdquo;</p>

<p><a href="/images/dellxps/dell_order_02.png"><img src="/images/dellxps/dell_order_02.png" width="500"></a></p>

<p><a href="/images/dellxps/dell_order_03.png"><img src="/images/dellxps/dell_order_03.png" width="500"></a></p>

<p><a href="/images/dellxps/dell_order_05.png"><img src="/images/dellxps/dell_order_04.png" width="500"></a></p>

<p>I have no clue what &ldquo;MUI Etikett für Handauflage&rdquo; is. It looks like some kind of internal article name. In English it means &ldquo;MUI sticker for palm rest&rdquo; which still makes little sense. I confirmed that the same issue is present on other European Dell stores. I checked Austrian and German sites. Same problem.</p>

<p>I honestly tried to contact support to get it done. Phone support in Switzerland does not provide help unless you have already bought something from Dell. I&rsquo;ve tried contacting other deparments and a support agent suggested I try chat support in Germany. I described the error and provided a screen-shot. The agent said it&rsquo;s a known problem and that it&rsquo;s going to be fixed. Just to be sure the agent recommended I try again tomorrow.</p>

<p>Well, the problem is still there 1.5 weeks later so I guess it&rsquo;s not going to be fixed anytime soon. Anyway, the point of this article is that it&rsquo;s possible to make an order by modifying JavaScript using Developer Tools (in Chrome) or an equivalent in other browsers. It&rsquo;s as simple as enabling the &ldquo;purchase&rdquo; button. Step by step instructions are provided below:</p>

<p>Find the HTML element in DOM that corresponds to the purchase button and remove the &ldquo;disabled&rdquo; class attribute::</p>

<p><a href="/images/dellxps/dell_order_06.png"><img src="/images/dellxps/dell_order_06.png" width="500"></a></p>

<p>Repeat the procedure on the next screen:</p>

<p><a href="/images/dellxps/dell_order_07.png"><img src="/images/dellxps/dell_order_07.png" width="500"></a></p>

<p><a href="/images/dellxps/dell_order_08.png"><img src="/images/dellxps/dell_order_08.png" width="500"></a></p>

<p>So far my order has not been cancelled but I don&rsquo;t know if it&rsquo;s going to work. If this fails I think I&rsquo;ll hold off buying a laptop at this time.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[5 sold gadgets later or welcome back to Microsoft Windows]]></title>
    <link href="http://drseergio.github.io/blog/2013/10/21/5-sold-gadgets-later-or-welcome-back-to-microsoft-windows/"/>
    <updated>2013-10-21T20:31:00+02:00</updated>
    <id>http://drseergio.github.io/blog/2013/10/21/5-sold-gadgets-later-or-welcome-back-to-microsoft-windows</id>
    <content type="html"><![CDATA[<p>I honestly would not anticipate writing about Microsoft Windows. Not after I have irrevocably and irreversibly switched to Linux and OSX years ago when I was studying at the university.</p>

<p>But here I am, happily typing this in Sublime2 editor on my desktop computer running nothing else but Microsoft Windows 8. Yes, the same computer that had been running Gentoo Linux a week or so ago!</p>

<!-- more -->


<p>Long story short I&rsquo;ve never intended this to happen. My goal was to reduce number of gadgets. Instead of a full-size tower PC and an Apple MacMini I wanted a single powerful machine running OSX. My idea was to buy a new motherboard with Thunderbolt ports (to connect two 27" Apple displays) and install OSX on to it. It&rsquo;s not an officially supported thing to do but I could not care less. The upcoming Apple MacPro is going to cost a fortune anyway and there is absolutely no way for me to justify such a steep price.</p>

<p><a href="/images/win8/3.jpg"><img src="/images/win8/3_s.jpg" width="500"></a></p>

<p>As you probably expect things did not go according to plan. It turned out that the motherboard I have ordered includes a Thunderbolt controller (DSL4510/4410) that is not yet supported by OSX (not even the latest Mavericks version). That left any attempts to install OSX out in the cold.</p>

<p><a href="/images/win8/9.jpg"><img src="/images/win8/9_s.jpg" width="500"></a></p>

<p>The reason I had an Apple computer in the first place was to natively run software that does not exist on Linux, such as Adobe imaging products. So I&rsquo;ve decided to install Windows and use all the same software on it. After all, the hardware I had put together has &ldquo;designed for Windows 8&rdquo; written all over it.</p>

<p>I was expecting a miserable experience. People love to bash Microsoft Windows and there are reasons for that. However, I found that the desktop experience works rather well and looks good. To be honest, I don&rsquo;t see much difference between operating systems for desktop work-loads because most of the time I use a web browser. Windows 8 does not stand in my way.</p>

<p>Every system has its quirks and Windows is no exception. I am used to quirks in all of the systems I have a pleasure to work with. The things I did not like about Windows:</p>

<ul>
<li><p>Installing drivers. In OSX almost everything is built-in. In Linux you either have a distribution with a binary kernel that includes support for almost every device or, if you&rsquo;re into it, you compile your own. Neither OSX nor Linux mandate messing with device support unless you really want to.</p></li>
<li><p>Updates. The dreadful updates plague OSX as well but not as much as Windows. I don&rsquo;t fully appreciate forced reboots and long installation times.</p></li>
<li><p>Lack of virtual desktops. Even with two 27" screens I like to have an option to switch to a different work-space. Both OSX and Linux have nailed this well. I&rsquo;ve found a program that enables virtual desktop but I don&rsquo;t know if it&rsquo;s doing its work efficiently. Perhaps I shouldn&rsquo;t care because the Intel i7 4740K is very fast and there&rsquo;s 16GB of system memory available.</p></li>
<li><p>Lack of good terminal. As a work-around I&rsquo;ve installed Console2 and Cygwin. It&rsquo;s an OK solution. I also SSH into a powerful Linux server (which acts as a <a href="/blog/2013/09/01/htpc-build-i-slash-m-proud-of/">HTPC</a> ) and keep a bunch of VMs around.</p></li>
<li><p>Sleep puts all windows on one monitor. In addition, the time is not immediately synced so I see the time when the computer was put to sleep.</p></li>
<li><p>Smaller behavior quirks that are solved by finding and installing utilities. For example:</p>

<ul>
<li>AltDrag to drag windows with a pointer while holding Alt pressed</li>
<li>AlwaysMouseWheel to scroll windows that are not in focus</li>
<li>TypeIt to enter German characters with a QWERTY layout</li>
<li>Dexpot for virtual desktops</li>
<li>ObjectDock for a OSX-like bar</li>
<li>ClipX as a clipboard history manager</li>
<li>NO, I do not need a &ldquo;start menu&rdquo; :D</li>
</ul>
</li>
</ul>


<p>The machine is exquisite! It&rsquo;s extremely quiet &ndash; it has only a single 120mm fan on the CPU heat-sink (I removed all the other fans). There are no extension cards and everything else is cooled passively. There&rsquo;s just one SSD and no vibrating hard disks. I can&rsquo;t tell if the computer is running or not! The Apple screens are gorgeous. I&rsquo;ve added a Logitech trackpad to do the touch gestures.</p>

<p><a href="/images/win8/4.jpg"><img src="/images/win8/4_s.jpg" width="500"></a></p>

<p>While I believe OSX might eventually support the Thunderbolt controller I don&rsquo;t plan to switch. The desktop experience is great and all the software I need works well. I&rsquo;ve sold all the gadgets, computers and computer parts I wanted through a local online auction. I feel much better now!</p>

<p>Full hardware list:</p>

<ul>
<li>Antec 1200 case (with all fans either removed or disabled)</li>
<li>Asus Z87 deluxe/dual motherboard</li>
<li>Intel 4770K</li>
<li>Noctua NH-U12P SE2 cooler</li>
<li>2x8GB RAM</li>
<li>Apple Cinema Display 27"</li>
<li>Apple Thunderbolt Screen 27"</li>
<li>Advantage Kinesis keyboard</li>
<li>Logitech M570 trackball</li>
<li>Logitech T650 multi-touch trackpad</li>
<li>Seasonic 460W passively-cooled PSU</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[My lucky night with a FreeNAS failure]]></title>
    <link href="http://drseergio.github.io/blog/2013/09/08/my-lucky-night-with-freenas-failure/"/>
    <updated>2013-09-08T01:34:00+02:00</updated>
    <id>http://drseergio.github.io/blog/2013/09/08/my-lucky-night-with-freenas-failure</id>
    <content type="html"><![CDATA[<p>It&rsquo;s 1:35am right now and something really bad has happened about 4 hours ago. First, Time Machine on my Mac Mini complained that the backup network disk became inaccessible. Then network shares have stopped responding on all computers. This means something wrong has happened with the wonderful reliable NAS server that I had built weeks ago.</p>

<p>First, I connect to the server via SSH and start poking around. Once I notice that file-system commands, such as <code>ls</code>, cause sessions to hang I become worrisome. I do a reboot hoping that solves the problem. 10 minutes pass. The server does not start.</p>

<!-- more -->


<p><img class="right" src="/images/chinese_monitor.jpg"></p>

<p>Once I&rsquo;ve connected a handy <a href="http://dx.com/p/8-tft-lcd-car-reverse-rear-view-color-monitor-w-vga-bnc-cable-black-149114">8" VGA monitor</a> I noticed SCSI driver related problems in the kernel logs. As it turns out, the USB drive on which FreeNAS had been installed has failed. This monitor is really handy for troubleshooting problems with servers &ndash; small, easy to carry and occupies little space in the toolbox. The picture quality is god-awful but good enough for reading terminal output.</p>

<p>I have been expecting the worst &ndash; that I would need to re-configure everything. After a quick search on the Internet I found out that FreeNAS keeps configuration in a SQLite database file on the 4th partition in <code>freenas-v1.db</code> file. A bleak hope ran through my mind. I&rsquo;ve connected the flash disk to a Linux computer and started poking around. All I needed to do was to compile UFS file-system support in kernel and then mount the partition with:</p>

<p><code>mount -r -t ufs -o ufstype=44bsd /dev/sdc4 /tmp/mm</code></p>

<p>I copied the file over and verified that it&rsquo;s not corrupted. YES! I had been stupidly postponing back-up of the configuration file. If I had to re-configure FreeNAS from scratch I would feel like a fool and waste a week worth of evenings. Now, I just need to burn the FreeNAS image to a replacement drive and I&rsquo;m all set.</p>

<p>The last step took embarassingly long time. None of the images that I had written either on Linux or Mac would boot. FreeNAS would get to an error saying <code>corrupt or invalid GPT detected.</code>. No matter what I did the outcome was the same. The solution was to delete GPT by running parted from Linux and doing <code>mklabel msdos</code>, followed by write of the disk image. I believe this problem occurred because I had previously used the drives for experimentation with Chromebook and some GPT headers apparently remained there.</p>

<p><img class="left" src="/images/msata.jpg"></p>

<p>Finally, I found a spare mSATA SSD drive lying around with no use (a leftover from a notebook upgrade). I also had a mSATA adapter so I&rsquo;ve put them together inside of the NAS to use as a boot device for FreeNAS. Now the NAS has 8 SATA devices (6 HDDs and 2 SSDs) maxing out all available SATA ports in the system.</p>

<p>Once I have successfully booted the server and got to the web UI and initiated import of the recovered configuration database file. Then the server rebooted twice and everything was back!</p>

<p>The machine is back online and running beautifully. I now have a backup of the configuration. In case anything goes wrong again reinstalling FreeNAS is really quick &amp; simple IFF the backup configuration file is available. I am once again pleasantly surprised at how well FreeNAS is made.</p>
]]></content>
  </entry>
  
</feed>
